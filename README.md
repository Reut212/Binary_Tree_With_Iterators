<div dir="rtl" lang="he">

# עץ בינארי עם איטרטורים

בקורס קודם למדנו על עצים בינאריים, ועל שלושת הדרכים לסייר בהם:
preorder, inorder, postorder.
במטלה הזאת מימשתי עץ בינארי עם איטרטורים שיכולים לעבור עליו בכל שלושת הסדרים.

שם המחלקה: `BinaryTree`.
השיטות הדרושות (ראו בקובץ [Demo.cpp](Demo.cpp) לפרטים):

* `add_root` - מקבלת קלט אחד ושמה אותו בשורש של העץ. אם כבר יש משהו בשורש, הוא מוחלף.
* `add_left` - מקבלת שני קלטים: הקלט הראשון מציין דבר שכבר קיים בעץ. הקלט השני מציין דבר חדש שיש להוסיף בתור הילד השמאלי שלו (אם כבר יש לו ילד שמאלי - יש להחליף את התוכן שלו). 
* `add_right` - כנ"ל, רק שהתוספת היא בתור הילד הימני.
* `begin_preorder()`, `end_preorder()` - מחזירות איטרטורים לצורך מעבר בסדר preorder (אב - שמאל - ימין).
* `begin_inorder()`, `end_inorder()` - מחזירות איטרטורים לצורך מעבר בסדר inorder (שמאל - אב - ימין).
* `begin_postorder()`, `end_postorder()` - מחזירות איטרטורים לצורך מעבר בסדר postorder (שמאל - ימין - אב).
* אופרטור פלט - מדפיס את העץ בפורמט הגיוני כלשהו לבחירתכם.

תוספות:
* **יעילות**: האיטרטור צריך להיות יעיל ככל האפשר מבחינת זיכרון. בפרט, אין לשמור את כל תוכן העץ בגוף האיטרטור..
* מימוש בנאי מעתיק ואופרטור השמה המבצעים **העתקה עמוקה**.
* מימוש בנאי מעביר ואופרטור העברה המבצעים **העתקה שטחית**.
* הפקודות `make test1`, `make test2`, `make test3`, `make tidy`, `make valgrind` מבצעות בדיקה לקוד.
* מימוש תוכנית ראשית יצירתית לצורך הדגמה; לצורך התוכנית, השתמשתי באלגוריתמים מהספריה התקנית.

</div>
